user www-data;
worker_processes 4;
pid /run/nginx.pid;
daemon off;

events {
  worker_connections  2048;
  multi_accept on;
  use epoll;
}

http {

#####################Start: Size Limits & Buffer Overflows ##
  client_body_buffer_size  1K;
  #(default is 8k or 16k) The directive specifies the client request body buffer size.
  client_header_buffer_size 1k;
  #Directive sets the headerbuffer size for the request header from client. For the overwhelming majority of requests a buffer size of 1K is sufficient. Increase this if you have a custom header or a large cookie sent from the client (e.g., wap client).
  client_max_body_size 7M;
  #Directive assigns the maximum accepted body size of client request, indicated by the line Content-Length in the header of request. If size is greater the given one, then the client gets the error “Request Entity Too Large” (413). Increase this when you are getting file uploads via the POST method.
  large_client_header_buffers 2 1k;
  #Directive assigns the maximum number and size of buffers for large headers to read from client request. By default the size of one buffer is equal to the size of page, depending on platform this either 4K or 8K, if at the end of working request connection converts to state keep-alive, then these buffers are freed. 2x1k will accept 2kB data URI. This will also help combat bad bots and DoS attacks.
####################### END: Size Limits & Buffer Overflows ##

######################### Start: Timeouts ##
  client_body_timeout   10;
  #Directive sets the read timeout for the request body from client. The timeout is set only if a body is not get in one readstep. If after this time the client send nothing, nginx returns error “Request time out” (408). The default is 60.
  client_header_timeout 10;
  #Directive assigns timeout with reading of the title of the request of client. The timeout is set only if a header is not get in one readstep. If after this time the client send nothing, nginx returns error “Request time out” (408).
  keepalive_timeout     5 5;
  #The first parameter assigns the timeout for keep-alive connections with the client. The server will close connections after this time. The optional second parameter assigns the time value in the header Keep-Alive: timeout=time of the response. This header can convince some browsers to close the connection, so that the server does not have to. Without this parameter, nginx does not send a Keep-Alive header (though this is not what makes a connection “keep-alive”).
  send_timeout          10;
  #Directive assigns response timeout to client. Timeout is established not on entire transfer of answer, but only between two operations of reading, if after this time client will take nothing, then nginx is shutting down the connection.
######################### End: Timeouts ##
  server_tokens off;
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  types_hash_max_size 2048;
  include /etc/nginx/mime.types;
  default_type application/octet-stream;
  access_log /dev/stdout;
  error_log /dev/stderr;
  gzip  on;

  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
  ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS';
  
  include /etc/nginx/conf.d/*.conf;
  include /etc/nginx/sites-available/*.conf;
  open_file_cache off; # Disabled for issue 619
  charset UTF-8;

  #limit_req_zone $binary_remote_addr zone=req_limit_per_ip:10m rate=2r/s;
  #limit_req_zone $server_name zone=req_perserver:10m rate=10r/s;
  #limit_req zone=req_limit_per_ip burst=20 nodelay;
  # limit_req zone=req_perserver burst=10;
  #limit_req_log_level notice;

  ## 用户的 IP 地址 $binary_remote_addr 作为 Key，每个 IP 地址最多有 5 个并发连接
  ## 你想开 几千个连接 刷死我？ 超过 5 个连接，直接返回 503 错误给你，根本不处理你的请求了

  #limit_conn_zone $binary_remote_addr zone=conn_limit_per_ip:10m;
  #limit_conn_zone $server_name zone=perserver:10m;

  ### Control maximum number of simultaneous connections for one session i.e. ###
  ### restricts the amount of connections from a single ip address ###

  #limit_conn conn_limit_per_ip 3;
  #limit_conn perserver 100;
  #limit_conn_log_level notice;

  ################## Directive describes the zone, in which the session states are stored i.e. store in slimits. ###
  ### 1m can handle 32000 sessions with 32 bytes/session, set to 5m x 32000 session ###
  #this feature not supportted in nginx 1.17.7
  #limit_zone slimits $binary_remote_addr 1m;
  ############################################################################
}
